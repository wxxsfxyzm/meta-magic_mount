import React, { useEffect, useState } from "react";
import { exec } from "kernelsu";
import locate from "./locate.json";
import "./index.css";

type Lang = keyof typeof locate; // "en" | "zh"
type Tab = "config" | "log";

type ConfigState = {
  moduledir: string;
  tempdir: string;
  mountsource: string;
  logfile: string;
  verbose: boolean;
  partitions: string[];
};

const DEFAULT_CONFIG: ConfigState = {
  moduledir: "/data/adb/modules/",
  tempdir: "",
  mountsource: "KSU",
  logfile: "/data/adb/magic_mount/mm.log",
  verbose: false,
  partitions: [],
};

const CONFIG_PATH = "/data/adb/magic_mount/config.toml";
const LOG_BASE = "/data/adb/magic_mount";

const App: React.FC = () => {
  // ---------- i18n ----------
  const [lang, setLang] = useState<Lang>(() => {
    if (typeof window === "undefined") return "en";
    const saved = window.localStorage.getItem("mm-lang");
    return saved === "zh" || saved === "en" ? (saved as Lang) : "en";
  });
  const L = locate[lang];

  const handleLangChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as Lang;
    setLang(value);
    if (typeof window !== "undefined") {
      window.localStorage.setItem("mm-lang", value);
    }
  };

  // ---------- tabs ----------
  const [activeTab, setActiveTab] = useState<Tab>("config");

  // ---------- config state ----------
  const [config, setConfig] = useState<ConfigState>(DEFAULT_CONFIG);
  const [configLoading, setConfigLoading] = useState(false);
  const [configSaving, setConfigSaving] = useState(false);
  const [configMessage, setConfigMessage] = useState<string | null>(null);

  // ---------- log state ----------
  const [logFile, setLogFile] = useState<"mm.log" | "mm.log.old">("mm.log");
  const [logContent, setLogContent] = useState("");
  const [logLoading, setLogLoading] = useState(false);
  const [logError, setLogError] = useState<string | null>(null);

  // ---------- partitions input ----------
  const [partitionInput, setPartitionInput] = useState("");

  // ---------- helpers ----------

  const parseTOMLConfig = (text: string): ConfigState | null => {
    try {
      const result: ConfigState = { ...DEFAULT_CONFIG };
      const lines = text.split("\n");

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) continue;

        const match = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
        if (!match) continue;

        const [, key, value] = match;
        const cleanValue = value.replace(/^["']|["']$/g, "").trim();

        switch (key) {
          case "moduledir":
          case "mountsource":
          case "logfile":
            result[key] = cleanValue;
            break;
          case "tempdir":
            result.tempdir = cleanValue;
            break;
          case "verbose":
            result.verbose = cleanValue === "true";
            break;
          case "partitions":
            // 解析数组格式: ["item1", "item2"] 或 []
            const arrayMatch = cleanValue.match(/^\[(.*)\]$/);
            if (arrayMatch) {
              const items = arrayMatch[1]
                .split(",")
                .map((s) => s.trim().replace(/^["']|["']$/g, ""))
                .filter((s) => s);
              result.partitions = items;
            }
            break;
        }
      }

      return result;
    } catch (e) {
      console.error("Failed to parse TOML:", e);
      return null;
    }
  };

  const serializeTOMLConfig = (cfg: ConfigState): string => {
    const lines: string[] = [
      "# Magic Mount Configuration File",
      "# Generated by Web UI",
      "",
      `moduledir = "${cfg.moduledir}"`,
    ];

    // 只有非空值才写入
    if (cfg.tempdir) {
      lines.push(`tempdir = "${cfg.tempdir}"`);
    }

    lines.push(
      `mountsource = "${cfg.mountsource}"`,
      `logfile = "${cfg.logfile}"`,
      `verbose = ${cfg.verbose}`
    );

    // 分区数组
    if (cfg.partitions.length > 0) {
      const partStr = cfg.partitions.map((p) => `"${p}"`).join(", ");
      lines.push(`partitions = [${partStr}]`);
    } else {
      lines.push("partitions = []");
    }

    return lines.join("\n");
  };

  // ---------- read config ----------
  const loadConfig = async () => {
    setConfigLoading(true);
    setConfigMessage(null);

    try {
      const { errno, stdout, stderr } = await exec(
        `[ -f "${CONFIG_PATH}" ] && cat "${CONFIG_PATH}" || echo ""`
      );

      if (errno !== 0) {
        console.error(stderr);
        setConfig(DEFAULT_CONFIG);
        setPartitionInput("");
        setConfigMessage(L.configReadError);
        return;
      }

      if (!stdout.trim()) {
        setConfig(DEFAULT_CONFIG);
        setPartitionInput("");
        setConfigMessage(L.configDefaultUsed);
        return;
      }

      const parsed = parseTOMLConfig(stdout);
      if (parsed) {
        setConfig(parsed);
        setPartitionInput(parsed.partitions.join(", "));
        setConfigMessage(L.configLoaded);
      } else {
        setConfig(DEFAULT_CONFIG);
        setPartitionInput("");
        setConfigMessage("Invalid TOML format");
      }
    } catch (e) {
      console.error(e);
      setConfig(DEFAULT_CONFIG);
      setPartitionInput("");
      setConfigMessage(L.configReadError);
    } finally {
      setConfigLoading(false);
    }
  };

  // ---------- save config ----------
  const saveConfig = async () => {
    setConfigSaving(true);
    setConfigMessage(null);

    try {
      const partitions = partitionInput
        .split(",")
        .map((s) => s.trim())
        .filter((s) => s);

      const configToSave = { ...config, partitions };

      const content = serializeTOMLConfig(configToSave);
      const escapedContent = content.replace(/'/g, "'\\''");

      const shell = `
        mkdir -p "$(dirname "${CONFIG_PATH}")" && \
        printf '%s\n' '${escapedContent}' > "${CONFIG_PATH}"
      `;

      const { errno, stderr } = await exec(shell);

      if (errno !== 0) {
        console.error(stderr);
        setConfigMessage(L.configSaveFailed);
      } else {
        setConfig(configToSave);
        setConfigMessage(L.configSaved);
      }
    } catch (e) {
      console.error(e);
      setConfigMessage(L.configSaveError);
    } finally {
      setConfigSaving(false);
    }
  };

  // ---------- read log ----------
  const loadLog = async () => {
    setLogLoading(true);
    setLogError(null);
    setLogContent("");
    try {
      const fullPath = `${LOG_BASE}/${logFile}`;
      const { errno, stdout, stderr } = await exec(
        `[ -f "${fullPath}" ] && cat "${fullPath}" || echo "Log file not found: ${fullPath}"`
      );

      if (errno !== 0) {
        console.error(stderr);
        setLogError(`${L.logReadFailed} (errno=${errno})`);
      } else {
        setLogContent(stdout || "");
      }
    } catch (e) {
      console.error(e);
      setLogError(L.logReadException);
    } finally {
      setLogLoading(false);
    }
  };

  // initial load config
  useEffect(() => {
    loadConfig();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // reload log when tab or file changed
  useEffect(() => {
    if (activeTab === "log") {
      loadLog();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeTab, logFile]);

  // ---------- render tabs ----------

  const renderConfigTab = () => (
    <div className="card">
      <h2>{L.config}</h2>

      {configLoading && <p className="hint">Loading...</p>}
      {configMessage && (
        <p className={configMessage.includes("Failed") || configMessage.includes("Invalid") ? "error" : "hint"}>
          {configMessage}
        </p>
      )}

      {/* Verbose switch */}
      <div className="field">
        <label>Verbose Logging</label>
        <div className="loglevel-switch">
          <button
            className={!config.verbose ? "lv-btn active" : "lv-btn"}
            onClick={() =>
              setConfig((prev) => ({
                ...prev,
                verbose: false,
              }))
            }
          >
            Off
          </button>
          <button
            className={config.verbose ? "lv-btn active" : "lv-btn"}
            onClick={() =>
              setConfig((prev) => ({
                ...prev,
                verbose: true,
              }))
            }
          >
            On
          </button>
        </div>
      </div>

      {/* Module Directory */}
      <div className="field">
        <label>moduledir</label>
        <input
          type="text"
          value={config.moduledir}
          placeholder={DEFAULT_CONFIG.moduledir}
          onChange={(e) =>
            setConfig((prev) => ({
              ...prev,
              moduledir: e.target.value,
            }))
          }
        />
      </div>

      {/* Temp Directory */}
      <div className="field">
        <label>tempdir</label>
        <input
          type="text"
          value={config.tempdir}
          placeholder="(auto-select if empty)"
          onChange={(e) =>
            setConfig((prev) => ({
              ...prev,
              tempdir: e.target.value,
            }))
          }
        />
      </div>

      {/* Mount Source */}
      <div className="field">
        <label>mountsource</label>
        <input
          type="text"
          value={config.mountsource}
          placeholder={DEFAULT_CONFIG.mountsource}
          onChange={(e) =>
            setConfig((prev) => ({
              ...prev,
              mountsource: e.target.value,
            }))
          }
        />
      </div>

      {/* Log File */}
      <div className="field">
        <label>logfile</label>
        <input
          type="text"
          value={config.logfile}
          placeholder={DEFAULT_CONFIG.logfile}
          onChange={(e) =>
            setConfig((prev) => ({
              ...prev,
              logfile: e.target.value,
            }))
          }
        />
      </div>

      {/* Partitions */}
      <div className="field">
        <label>partitions</label>
        <input
          type="text"
          value={partitionInput}
          placeholder="e.g., mi_ext,my_stock"
          onChange={(e) => setPartitionInput(e.target.value)}
        />
      </div>

      <div className="actions">
        <button onClick={loadConfig} disabled={configLoading || configSaving}>
          {L.reload}
        </button>
        <button
          className="primary"
          onClick={saveConfig}
          disabled={configSaving || configLoading}
        >
          {configSaving ? "Saving..." : L.saveConfig}
        </button>
      </div>

      <p className="path">
        Config Path: {CONFIG_PATH}
      </p>
    </div>
  );

  const renderLogTab = () => (
    <div className="card">
      <h2>{L.logView}</h2>

      <div className="field">
        <label>{L.selectLog}</label>
        <div className="log-select-row">
          <select
            value={logFile}
            onChange={(e) =>
              setLogFile(e.target.value as "mm.log" | "mm.log.old")
            }
          >
            <option value="mm.log">mm.log</option>
            <option value="mm.log.old">mm.log.old</option>
          </select>

          <button className="refresh-btn" onClick={loadLog} disabled={logLoading}>
            {logLoading ? "Loading..." : L.refreshLog}
          </button>
        </div>
      </div>

      {logError && <p className="error">{logError}</p>}

      <pre className="log-view">
        {logLoading && !logContent ? "Loading..." : logContent || L.emptyLog}
      </pre>
    </div>
  );

  return (
    <div className="app-root">
      {/* top bar with language selector */}
      <div className="top-bar">
        <div className="title">Magic Mount</div>

        <select
          className="lang-select"
          value={lang}
          onChange={handleLangChange}
        >
          <option value="en">English</option>
          <option value="zh">中文</option>
        </select>
      </div>

      <div className="app-main">
        {activeTab === "config" ? renderConfigTab() : renderLogTab()}
      </div>

      {/* bottom tabs */}
      <div className="bottom-bar">
        <button
          className={activeTab === "config" ? "tab-btn active" : "tab-btn"}
          onClick={() => setActiveTab("config")}
        >
          {L.configTab}
        </button>
        <button
          className={activeTab === "log" ? "tab-btn active" : "tab-btn"}
          onClick={() => setActiveTab("log")}
        >
          {L.logTab}
        </button>
      </div>
    </div>
  );
};

export default App;
